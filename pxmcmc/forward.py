import pys2let
import numpy as np
import healpy as hp
from scipy.special import sph_harm
from pxmcmc.utils import expand_mlm, alm2map, wavelet_basis


class ForwardOperator:
    """
    Base Forward operator
    Children of this class must define analysis/synthesis forward and gradg functions
    Children must also take data and sig_d in the constructor
    """

    def __init__(self, data, sig_d, setting="analysis"):
        self.data = data
        self.sig_d = sig_d
        assert setting in ["analysis", "synthesis"]
        self.setting = setting

    def forward(self, X):
        if self.setting == "analysis":
            return self._forward_analysis(X)
        else:
            return self._forward_synthesis(X)

    def calc_gradg(self, preds):
        if self.setting == "analysis":
            return self._gradg_analysis(preds)
        else:
            return self._gradg_synthesis(preds)

    def _forward_analysis(self, X):
        raise NotImplementedError

    def _forward_synthesis(self, X):
        raise NotImplementedError

    def _gradg_analysis(self, X):
        raise NotImplementedError

    def _gradg_synthesis(self, X):
        raise NotImplementedError


class ISWTOperator(ForwardOperator):
    """
    Inverse spherical wavelet transfrom operator.
    Returns the spherical harmonic coefficients from the sampled harmonic wavelet coeffs
    """

    def __init__(self, data, sig_d, L, B, J_min, dirs=1, spin=0):
        super().__init__(data, sig_d)
        self.L = L
        self.B = B
        self.J_min = J_min
        self.J_max = pys2let.pys2let_j_max(self.B, self.L, self.J_min)
        self.nscales = self.J_max - self.J_min + 1
        self.dirs = dirs
        self.spin = spin

        self.basis = wavelet_basis(self.L, self.B, self.J_min)
        self.n_bases = self.basis.shape[1]
        self.nparams = np.prod(self.basis.shape)

        self._get_base_l0s()
        self._calc_prefactors()

    def forward(self, X):
        """
        Forward modelling.  Takes a vector X containing the scaling and wavelet coefficients generated by the chain and predicts output harmonic space map
        """
        wav_lm, scal_lm = expand_mlm(X, self.nscales)
        scal_lm_hp = pys2let.lm2lm_hp(scal_lm, self.L + 1)
        wav_lm_hp = np.zeros(
            [(self.L + 1) * (self.L + 2) // 2, self.nscales], dtype=np.complex,
        )
        for j in range(self.nscales):
            wav_lm_hp[:, j] = pys2let.lm2lm_hp(
                np.ascontiguousarray(wav_lm[:, j]), self.L + 1
            )
        clm_hp = pys2let.synthesis_axisym_lm_wav(
            wav_lm_hp, scal_lm_hp, self.B, self.L + 1, self.J_min
        )
        clm = pys2let.lm_hp2lm(clm_hp, self.L + 1)
        return clm

    def calc_gradg(self, preds):
        """
        Calculates the gradient of the data fidelity term, which should guide the MCMC search.
        """
        diff = np.concatenate([preds - self.data] * self.n_bases)
        gradg = self.pf * diff / (self.sig_d ** 2)
        return gradg

    def _get_base_l0s(self):
        self.base_l0s = np.zeros((self.n_bases, self.L + 1), dtype=np.complex)
        for i, base in enumerate(self.basis.T):
            self.base_l0s[i] = [base[l ** 2 + l] for l in range(self.L + 1)]

    def _calc_prefactors(self):
        """
        Calculates prefactors of gradg which are constant throughout the chain, and so only need to be calculated once at the start.
        """
        prefactors = np.zeros(self.nparams, dtype=np.complex)
        for i, base in enumerate(self.basis.T):
            for ell in range(self.L + 1):
                prefactors[
                    i * len(base) + ell ** 2 : i * len(base) + (ell + 1) ** 2
                ] = (np.sqrt(4 * np.pi / (2 * ell + 1)) * self.base_l0s[i, ell])
        self.pf = prefactors


class SWC2PixOperator(ISWTOperator):
    def __init__(self, data, sig_d, Nside, L, B, J_min, dirs=1, spin=0):
        self.Nside = Nside
        super().__init__(data, sig_d, L, B, J_min, dirs, spin)

    def forward(self, X):
        clm = super().forward(X)
        clm_hp = pys2let.lm2lm_hp(clm, self.L + 1)
        c = alm2map(clm_hp, self.Nside)
        return c

    def calc_gradg(self, preds):
        diff = preds - self.data
        product = diff * self.pf.T
        sum_over_pixels = np.sum(product, axis=1)
        return sum_over_pixels / (self.sig_d ** 2)

    def _calc_prefactors(self):
        """
        This will be prohibitively large at high Nside or high L
        """
        super()._calc_prefactors()
        theta, phi = hp.pix2ang(self.Nside, np.arange(hp.nside2npix(self.Nside)))
        Ylms = np.zeros(
            ((self.L + 1) ** 2, hp.nside2npix(self.Nside)), dtype=np.complex
        )
        for el in range(self.L + 1):
            for em in range(-el, el + 1):
                Ylms[el ** 2 + el + em] = sph_harm(em, el, phi, theta)
        self.pf = self.pf * np.concatenate([Ylms] * self.n_bases).T
